euriklis.Mathematics.complexMatrix.prototype.eigenProblem = function (B) {
	return lzit(... lzhes(this, B));
}
lzhes = (a, b, wantx) => {
	let x, y, w, z, n, c, d, nm1, jm2, jp1,
	i, j, k, ip1, ii, abs = Math.abs, nm2,
	complex = euriklis.Mathematics.complex, 
	zero =  new complex(0), one =  new complex(1);
	n = a.rows, im1, imj, cabs = (z) => {
		return abs(z.Re) + abs(z.Im)
	},
	isZero = (z) => {
		return z.Re === 0 && z.Im === 0;
	};
	nm1 = n - 1;
	for (i = 1;i <= nm1;i++) {
		d = 0;
		ip1 = i + 1;
		for (k = ip1;k <= n;k++) {
			y = b.z[k - 1][i - 1];
			c = abs(y.Re) + abs(y.Im);
			if (c <= d) continue;
			d = c;
			ii = k;
		}
		if (d === 0) continue;
		y = b.z[i - 1][i - 1];
		if (d > abs(y.Re) + abs(y.Im)) {
			for (j = 1;j <= n;j++) {
				y = a.z[i - 1][j - 1];
				a.z[i - 1][j - 1] = a.z[ii - 1][j - 1];
				a.z[ii - 1][j - 1] = y;
			}
			for (j = 1;j <= n;j++) {
				y = b.z[i - 1][j - 1];
				b.z[i - 1][j - 1] = b.z[ii - 1][j - 1];
				b.z[ii - 1][j - 1] = y;
			}
		}
		for (j = ip1;j <= n;j++) {
			y = b.z[j - 1][i - 1].divide(b.z[i - 1][i - 1]);
			if (y.Re === 0 && y.Im === 0) continue;
			for (k = 1;k <= n;k++) {
				a.z[j - 1][k - 1] = a.z[j - 1][k - 1].minus(y.times(a.z[i - 1][k - 1]));
			}
			for (k = ip;k <= n;k++) {
				b.z[j - 1][k - 1] = b.z[j - 1][k - 1].minus(y.times(b.z[i - 1][k - 1]));
			}
		}
		b.z[ip1 - 1][i - 1] = zero;
	}
	/**
	 * initialize x:
	 */
	if (wantx) {
		x = new complexMatrix(n, n);
		for (i = 1;i <= n;i++) {
			for (j = 1;j <= n;j++) x.z[i - 1][j - 1] = zero;
			x.z[i - 1][i - 1] = one;
		}
	}
   /**
    * reduce a to upper hessenberg:
    */
	nm2 = n - 2;
	if (nm2 > 1) {
		for (j = 1;j <= nm2;j++) {
			jm2 = nm1 - j;
			jp1 = j + 1;
			for (ii = 1;ii <= jm2;ii++) {
				i = n + 1 - ii;
				im1 = i - 1;
				imj = i - j;
				w - a.z[i - 1][j - 1];
				z = a.z[im1 - 1][j - 1];
				if (cabs(w) > cabs(z)) {
					/**
					 * must interchange rows:
					 */
					for (k = j;k <= n;k++) {
						y = a.z[i - 1][k - 1];
						a.z[i - 1][k - 1] = a.z[im1 - 1][k - 1];
						a.z[im1 - 1][k - 1] = y;
					}
					for (k = im1;k <= n;k++) {
						y = b.z[i - 1][k - 1];
						b.z[i - 1][k - 1] = b.z[im1 - 1][k - 1];
						b.z[im1 - 1][k - 1] = y;
					}
				}
				z = a.z[i - 1][j - 1];
				if (!isZero(z)) {
					y = z.divide(a.z[im1 - 1][j - 1]);
					for (k = jp1;k <= n;k++) {
						a.z[i - 1][k - 1] = a.z[i - 1][k - 1].minus(y.times(a.z[im1 - 1][k - 1]))
					}
					for (k = im1;k <= n;k++) {
						b.z[i - 1][k - 1] = b.z[i - 1][k - 1].minus(y.times(b.z[im1 - 1][k - 1]))
					}
				}
				/**
				 * transformation from the right:
				 */
				w = b.z[i - 1][im1 - 1];
				z = b.z[i - 1][i - 1];
				if (cabs(w) > cabs(z)) {
					for (k = 1;k <= i;k++) {
						y = b.z[k - 1][i - 1];
						b.z[k - 1][i - 1] = b.z[k - 1][im1 - 1];
						b.z[k - 1][im1 - 1] = y;
					}
					for (k = 1;k <= n;k++) {
						y = a.z[k - 1][i - 1];
						a.z[k - 1][i - 1] = a.z[k - 1][im1 - 1];
						a.z[k - 1][im1 - 1] = y;
					}
					if (wantx) {
						for (k = imj;k <= n;k++) {
							y = x.z[k - 1][i - 1];
							x.z[k -1][i - 1] = x.z[k - 1][im1 - 1];
							x.z[k - 1][im1 - 1] = y;
						}
					}
				}
				z = b.z[i - 1][im1 - 1];
				if (!isZero(z)) {
					y = z.divide(b.z[i - 1][i - 1]);
					for (k = 1;k <= im1;k++) {
						b.z[k - 1][im1 - 1] = b.z[k - 1][im1 - 1].minus(y.times(b.z[k - 1][i - 1]));
					}
					b.z[i - 1][im1 - 1] = zero;
					for (k = 1;k <= n;k++) {
						a.z[k - 1][im1 - 1] = a.z[k - 1][im1 - 1].minus(y.times(a.z[k - 1][i - 1]));
					}
					if (wantx) {
						for (k = imj;k <= n;k++) {
							x.z[k - 1][im1 - 1] = x.z[k - 1][im1 - 1].minus(y.times(x.z[k - 1][i - 1]));
						}
					}
				}
			}
			a.z[jp1 - 1][j - 1] = zero;
		}
	}
	return [a, b, x];
}